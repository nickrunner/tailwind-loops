<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Scoring Tuner</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; display: flex; flex-direction: column; height: 100vh; background: #1a1a2e; color: #e0e0e0; }

  .top-bar { display: flex; align-items: center; padding: 8px 16px; background: #16213e; border-bottom: 1px solid #0f3460; gap: 16px; flex-shrink: 0; }
  .top-bar h1 { font-size: 16px; font-weight: 600; white-space: nowrap; }
  .top-bar select { background: #0f3460; color: #e0e0e0; border: 1px solid #533483; padding: 4px 8px; border-radius: 4px; font-size: 13px; }
  .top-bar .status { margin-left: auto; font-size: 12px; color: #8888aa; }

  .main { display: flex; flex: 1; overflow: hidden; }

  .sidebar { width: 300px; overflow-y: auto; padding: 12px; background: #16213e; border-right: 1px solid #0f3460; flex-shrink: 0; }
  .sidebar h2 { font-size: 13px; font-weight: 600; text-transform: uppercase; color: #888; margin: 12px 0 6px; letter-spacing: 0.5px; }
  .sidebar h2:first-child { margin-top: 0; }

  .slider-row { display: flex; align-items: center; margin: 4px 0; gap: 6px; }
  .slider-row label { font-size: 12px; width: 110px; flex-shrink: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .slider-row input[type="range"] { flex: 1; min-width: 0; accent-color: #533483; }
  .slider-row .val { font-size: 11px; width: 38px; text-align: right; font-family: monospace; flex-shrink: 0; color: #aaa; }

  .section { margin-bottom: 8px; }
  .section-header { cursor: pointer; user-select: none; font-size: 12px; font-weight: 600; color: #bbb; padding: 4px 0; display: flex; align-items: center; gap: 4px; }
  .section-header::before { content: '\25B6'; font-size: 9px; transition: transform 0.2s; display: inline-block; }
  .section-header.open::before { transform: rotate(90deg); }
  .section-body { display: none; padding-left: 4px; }
  .section-body.open { display: block; }

  .checkbox-row { display: flex; align-items: center; margin: 3px 0; gap: 6px; font-size: 12px; }
  .checkbox-row input[type="checkbox"] { accent-color: #533483; }

  .btn { background: #0f3460; color: #e0e0e0; border: 1px solid #533483; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-top: 12px; width: 100%; }
  .btn:hover { background: #533483; }

  .dist-btn { background: #4a1a4a; color: #e0e0e0; border: 1px solid #7a2d7a; padding: 4px 6px; border-radius: 4px; cursor: pointer; font-size: 11px; min-width: 48px; text-align: center; }
  .dist-btn:hover { background: #7a2d7a; }
  .dist-btn.active { background: #9333ea; border-color: #a855f7; }
  .dist-btn:disabled { opacity: 0.5; cursor: wait; }

  #map { flex: 1; }

  .footer { padding: 6px 16px; background: #16213e; border-top: 1px solid #0f3460; font-size: 12px; color: #8888aa; flex-shrink: 0; }

  /* Leaflet popup */
  .score-popup { font-family: monospace; font-size: 11px; line-height: 1.6; }
  .score-popup .name { font-family: sans-serif; font-weight: 600; font-size: 13px; margin-bottom: 4px; }
  .score-popup .bar { display: inline-block; height: 10px; border-radius: 2px; vertical-align: middle; margin-right: 4px; }
</style>
</head>
<body>

<div class="top-bar">
  <h1>Scoring Tuner</h1>
  <label>
    Activity:
    <select id="activity">
      <option value="road-cycling">Road Cycling</option>
      <option value="gravel-cycling">Gravel Cycling</option>
      <option value="running">Running</option>
      <option value="walking">Walking</option>
    </select>
  </label>
  <label>
    Profile:
    <select id="profile">
      <option value="">(base)</option>
    </select>
  </label>
  <span class="status" id="status">Loading...</span>
</div>

<div class="main">
  <div class="sidebar" id="sidebar">
    <div class="checkbox-row" style="margin-bottom:4px">
      <input type="checkbox" id="show-network" checked>
      <label for="show-network" style="font-weight:600">Show Corridor Network</label>
    </div>
    <div class="checkbox-row" style="margin-bottom:8px">
      <input type="checkbox" id="show-connectors">
      <label for="show-connectors" style="font-weight:600">Show Connectors</label>
    </div>

    <h2>Corridor Types</h2>
    <div id="visibility-section"></div>

    <h2>Dimension Weights</h2>
    <div id="weights-section"></div>

    <div class="section">
      <div class="section-header" data-section="flow">Flow Params</div>
      <div class="section-body" id="flow-section"></div>
    </div>

    <div class="section">
      <div class="section-header" data-section="safety">Safety Sub-Weights</div>
      <div class="section-body" id="safety-section"></div>
    </div>

    <div class="section">
      <div class="section-header" data-section="character">Character Scores</div>
      <div class="section-body" id="character-section"></div>
    </div>

    <div class="section">
      <div class="section-header" data-section="surface">Surface Scores</div>
      <div class="section-body" id="surface-section"></div>
    </div>

    <div class="section">
      <div class="section-header" data-section="scenic">Scenic Params</div>
      <div class="section-body" id="scenic-section"></div>
    </div>

    <div class="section">
      <div class="section-header" data-section="elevation">Elevation Params</div>
      <div class="section-body" id="elevation-section"></div>
    </div>

    <div class="section">
      <div class="section-header" data-section="confidence">Surface Confidence</div>
      <div class="section-body" id="confidence-section"></div>
    </div>

    <h2>Generate Route</h2>
    <div id="distance-buttons" style="display:flex;flex-wrap:wrap;gap:4px;margin-bottom:8px"></div>

    <button class="btn" id="reset-btn">Reset Defaults</button>
    <button class="btn" id="save-btn" style="background:#1a4a1a;border-color:#2d7a2d">Save</button>
    <button class="btn" id="save-as-btn" style="background:#1a3a4a;border-color:#2d6a7a">Save as New Profile</button>
  </div>

  <div id="map"></div>
</div>

<div class="footer" id="footer">Initializing...</div>

<script>
// ---------------------------------------------------------------------------
// State
// ---------------------------------------------------------------------------
let params = null;
let debounceTimer = null;
let corridorLayer = null;
let connectorLayer = null;
let highlightGroup = null;
let routeLayer = null;
let startMarker = null;
let map = null;
let lastGeoJson = null;
let moveDebounceTimer = null;
let loadInFlight = false;
let currentProfile = null; // null = base, string = profile name
let profileList = [];

const ALL_CORRIDOR_TYPES = ['trail', 'path', 'neighborhood', 'rural-road', 'collector', 'arterial', 'mixed'];

// Which corridor types are hidden by default per activity
const HIDDEN_BY_DEFAULT = {
  'road-cycling': new Set(['trail', 'path']),
  'gravel-cycling': new Set([]),
  'running': new Set([]),
  'walking': new Set([]),
};

// Current visibility state: type → boolean
let visibleTypes = {};

const ACTIVITY_LABELS = {
  'road-cycling': 'Road Cycling',
  'gravel-cycling': 'Gravel Cycling',
  'running': 'Running',
  'walking': 'Walking',
};

// ---------------------------------------------------------------------------
// Slider builder
// ---------------------------------------------------------------------------
function makeSlider(container, key, label, value, min, max, step) {
  const row = document.createElement('div');
  row.className = 'slider-row';

  const lbl = document.createElement('label');
  lbl.textContent = label;
  lbl.title = key;

  const input = document.createElement('input');
  input.type = 'range';
  input.min = min;
  input.max = max;
  input.step = step;
  input.value = value;
  input.dataset.key = key;

  const valSpan = document.createElement('span');
  valSpan.className = 'val';
  valSpan.textContent = Number(value).toFixed(2);

  input.addEventListener('input', () => {
    valSpan.textContent = Number(input.value).toFixed(2);
    scheduleScore();
  });

  row.append(lbl, input, valSpan);
  container.appendChild(row);
  return input;
}

// ---------------------------------------------------------------------------
// Build all controls from params
// ---------------------------------------------------------------------------
const sliders = {};

function buildVisibilityControls() {
  const activity = document.getElementById('activity').value;
  const hidden = HIDDEN_BY_DEFAULT[activity] || new Set();

  // Reset visibility for current activity
  visibleTypes = {};
  for (const t of ALL_CORRIDOR_TYPES) {
    visibleTypes[t] = !hidden.has(t);
  }

  const container = document.getElementById('visibility-section');
  container.innerHTML = '';
  for (const t of ALL_CORRIDOR_TYPES) {
    const row = document.createElement('div');
    row.className = 'checkbox-row';

    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.id = `vis-${t}`;
    cb.checked = visibleTypes[t];
    cb.addEventListener('change', () => {
      visibleTypes[t] = cb.checked;
      rerenderFromCache();
    });

    const lbl = document.createElement('label');
    lbl.htmlFor = `vis-${t}`;
    lbl.textContent = t;

    row.append(cb, lbl);
    container.appendChild(row);
  }
}

function buildControls() {
  if (!params) return;

  buildVisibilityControls();

  // Dimension weights
  const wc = document.getElementById('weights-section');
  wc.innerHTML = '';
  sliders.weights = {};
  for (const [k, v] of Object.entries(params.weights)) {
    sliders.weights[k] = makeSlider(wc, `weights.${k}`, k, v, 0, 1, 0.01);
  }

  // Flow params
  const fc = document.getElementById('flow-section');
  fc.innerHTML = '';
  sliders.flow = {};
  const flowDefs = {
    lengthLogDenominator: { label: 'Length log denom', min: 50, max: 2000, step: 10 },
    lengthLogNumerator: { label: 'Length log numer', min: 1000, max: 50000, step: 100 },
    stopDecayRate: { label: 'Stop decay rate', min: 0, max: 1, step: 0.01 },
    lengthBlend: { label: 'Length blend', min: 0, max: 1, step: 0.01 },
  };
  for (const [k, def] of Object.entries(flowDefs)) {
    sliders.flow[k] = makeSlider(fc, `flow.${k}`, def.label, params.flow[k], def.min, def.max, def.step);
  }

  // Safety sub-weights
  const sc = document.getElementById('safety-section');
  sc.innerHTML = '';
  sliders.safety = {};
  for (const [k, v] of Object.entries(params.safety)) {
    sliders.safety[k] = makeSlider(sc, `safety.${k}`, k, v, 0, 1, 0.01);
  }

  // Character scores
  const cc = document.getElementById('character-section');
  cc.innerHTML = '';
  sliders.character = {};
  for (const [k, v] of Object.entries(params.characterScores)) {
    sliders.character[k] = makeSlider(cc, `character.${k}`, k, v, 0, 1, 0.01);
  }

  // Surface scores
  const sfc = document.getElementById('surface-section');
  sfc.innerHTML = '';
  sliders.surface = {};
  for (const [k, v] of Object.entries(params.surfaceScores)) {
    sliders.surface[k] = makeSlider(sfc, `surface.${k}`, k, v, 0, 1, 0.01);
  }

  // Scenic params
  const snc = document.getElementById('scenic-section');
  snc.innerHTML = '';
  sliders.scenic = {};
  sliders.scenic.scenicBoost = makeSlider(
    snc, 'scenicBoost', 'Scenic boost', params.scenicBoost ?? 1.0, 0, 3, 0.01
  );

  // Elevation params
  const elc = document.getElementById('elevation-section');
  elc.innerHTML = '';
  sliders.elevation = {};
  const elevParams = params.elevation || {};

  // Hill preference dropdown
  const prefRow = document.createElement('div');
  prefRow.className = 'slider-row';
  const prefLabel = document.createElement('label');
  prefLabel.textContent = 'Hill preference';
  const prefSelect = document.createElement('select');
  prefSelect.style.cssText = 'flex:1;background:#0f3460;color:#e0e0e0;border:1px solid #533483;padding:2px 4px;border-radius:4px;font-size:12px;';
  for (const opt of ['any', 'flat', 'rolling', 'hilly']) {
    const o = document.createElement('option');
    o.value = opt;
    o.textContent = opt;
    if ((elevParams.hillPreference || 'any') === opt) o.selected = true;
    prefSelect.appendChild(o);
  }
  prefSelect.addEventListener('change', scheduleScore);
  prefRow.append(prefLabel, prefSelect);
  elc.appendChild(prefRow);
  sliders.elevation.hillPreference = prefSelect;

  const elevDefs = {
    flatPenaltyRate: { label: 'Flat penalty rate', min: 0, max: 20, step: 0.5 },
    rollingIdealHilliness: { label: 'Rolling ideal', min: 0, max: 1, step: 0.01 },
    rollingWidth: { label: 'Rolling width', min: 0.01, max: 1, step: 0.01 },
    hillyBonusRate: { label: 'Hilly bonus rate', min: 0, max: 20, step: 0.5 },
    maxGradePenaltyThreshold: { label: 'Max grade thresh', min: 0, max: 40, step: 1 },
    gradeSensitivity: { label: 'Grade sensitivity', min: 0, max: 20, step: 0.5 },
  };
  for (const [k, def] of Object.entries(elevDefs)) {
    sliders.elevation[k] = makeSlider(elc, `elevation.${k}`, def.label, elevParams[k] ?? 0, def.min, def.max, def.step);
  }

  // Crossing decay rate (character param)
  const cc2 = document.getElementById('character-section');
  sliders.crossingDecayRate = makeSlider(
    cc2, 'crossingDecayRate', 'Crossing decay', params.crossingDecayRate ?? 0.04, 0, 0.3, 0.005
  );

  // Surface confidence min factor
  const cfc = document.getElementById('confidence-section');
  cfc.innerHTML = '';
  sliders.confidence = {};
  sliders.confidence.surfaceConfidenceMinFactor = makeSlider(
    cfc, 'surfaceConfidenceMinFactor', 'Min factor', params.surfaceConfidenceMinFactor, 0, 1, 0.01
  );
}

// ---------------------------------------------------------------------------
// Read params from sliders
// ---------------------------------------------------------------------------
function readParams() {
  // Dimension weights — normalize to sum to 1
  const rawWeights = {};
  let wSum = 0;
  for (const [k, slider] of Object.entries(sliders.weights)) {
    rawWeights[k] = Number(slider.value);
    wSum += rawWeights[k];
  }
  const weights = {};
  for (const k of Object.keys(rawWeights)) {
    weights[k] = wSum > 0 ? rawWeights[k] / wSum : 0.25;
  }

  // Safety sub-weights — normalize to sum to 1
  const rawSafety = {};
  let sSum = 0;
  for (const [k, slider] of Object.entries(sliders.safety)) {
    rawSafety[k] = Number(slider.value);
    sSum += rawSafety[k];
  }
  const safety = {};
  for (const k of Object.keys(rawSafety)) {
    safety[k] = sSum > 0 ? rawSafety[k] / sSum : 0.25;
  }

  // Flow params (not normalized)
  const flow = {};
  for (const [k, slider] of Object.entries(sliders.flow)) {
    flow[k] = Number(slider.value);
  }

  // Character scores (not normalized)
  const characterScores = {};
  for (const [k, slider] of Object.entries(sliders.character)) {
    characterScores[k] = Number(slider.value);
  }

  // Surface scores (not normalized)
  const surfaceScores = {};
  for (const [k, slider] of Object.entries(sliders.surface)) {
    surfaceScores[k] = Number(slider.value);
  }

  // Elevation params
  const elevation = {
    hillPreference: sliders.elevation.hillPreference.value,
    flatPenaltyRate: Number(sliders.elevation.flatPenaltyRate.value),
    rollingIdealHilliness: Number(sliders.elevation.rollingIdealHilliness.value),
    rollingWidth: Number(sliders.elevation.rollingWidth.value),
    hillyBonusRate: Number(sliders.elevation.hillyBonusRate.value),
    maxGradePenaltyThreshold: Number(sliders.elevation.maxGradePenaltyThreshold.value),
    gradeSensitivity: Number(sliders.elevation.gradeSensitivity.value),
  };

  return {
    weights,
    flow,
    safety,
    surfaceScores,
    characterScores,
    crossingDecayRate: Number(sliders.crossingDecayRate.value),
    surfaceConfidenceMinFactor: Number(sliders.confidence.surfaceConfidenceMinFactor.value),
    scenicBoost: Number(sliders.scenic.scenicBoost.value),
    elevation,
  };
}

// ---------------------------------------------------------------------------
// Scoring
// ---------------------------------------------------------------------------
function scheduleScore() {
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(doScore, 150);
}

async function doScore() {
  const activity = document.getElementById('activity').value;
  const currentParams = readParams();

  document.getElementById('status').textContent = 'Scoring...';
  const start = performance.now();

  try {
    const res = await fetch('/api/score', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ activityType: activity, params: currentParams }),
    });
    const geojson = await res.json();
    const elapsed = Math.round(performance.now() - start);

    if (geojson.error) {
      document.getElementById('footer').textContent = `Error: ${geojson.error}`;
      return;
    }

    lastGeoJson = geojson;
    renderGeoJson(geojson);
    renderConnectors(geojson._connectors);

    const meta = geojson._meta || {};
    const visibleCount = corridorLayer ? corridorLayer.getLayers().length : meta.corridorCount;
    const connectorInfo = meta.connectorCount ? ` | ${meta.connectorCount} connectors` : '';
    document.getElementById('footer').textContent =
      `Showing ${visibleCount} of ${meta.corridorCount ?? '?'} corridors${connectorInfo} | Scored in ${meta.scoringTimeMs ?? '?'}ms (server) / ${elapsed}ms (round-trip)`;
    document.getElementById('status').textContent = 'Ready';
  } catch (err) {
    document.getElementById('footer').textContent = `Fetch error: ${err.message}`;
    document.getElementById('status').textContent = 'Error';
  }
}

// ---------------------------------------------------------------------------
// Map rendering
// ---------------------------------------------------------------------------
function rerenderFromCache() {
  if (!lastGeoJson) return;
  renderGeoJson(lastGeoJson);
  const meta = lastGeoJson._meta || {};
  const visibleCount = corridorLayer ? corridorLayer.getLayers().length : 0;
  document.getElementById('footer').textContent =
    `Showing ${visibleCount} of ${meta.corridorCount ?? '?'} corridors`;
}

function clearHighlight() {
  if (highlightGroup) {
    map.removeLayer(highlightGroup);
    highlightGroup = null;
  }
}

function renderGeoJson(geojson) {
  if (corridorLayer) {
    map.removeLayer(corridorLayer);
  }

  // Filter out hidden corridor types
  const filtered = {
    ...geojson,
    features: geojson.features.filter(f => visibleTypes[f.properties.corridorType] !== false),
  };

  corridorLayer = L.geoJSON(filtered, {
    style: (feature) => ({
      color: feature.properties.stroke || '#888',
      weight: feature.properties['stroke-width'] || 3,
      opacity: feature.properties['stroke-opacity'] || 0.85,
    }),
    onEachFeature: (feature, layer) => {
      layer.on('click', () => {
        clearHighlight();

        // Build highlight: thick outline + start/end markers
        const coords = feature.geometry.coordinates;
        const latlngs = (feature.geometry.type === 'MultiLineString'
          ? coords.flat()
          : coords
        ).map(c => [c[1], c[0]]);

        const highlight = L.polyline(latlngs, {
          color: '#00ffff',
          weight: 7,
          opacity: 1,
          interactive: false,
        });

        const startPt = latlngs[0];
        const endPt = latlngs[latlngs.length - 1];
        const startMarker = L.circleMarker(startPt, {
          radius: 6, color: '#fff', fillColor: '#22cc22', fillOpacity: 1, weight: 2, interactive: false,
        });
        const endMarker = L.circleMarker(endPt, {
          radius: 6, color: '#fff', fillColor: '#cc2222', fillOpacity: 1, weight: 2, interactive: false,
        });

        highlightGroup = L.layerGroup([highlight, startMarker, endMarker]).addTo(map);

        // Build popup
        const p = feature.properties;
        const barHtml = (score, label) => {
          const pct = Math.round((score ?? 0) * 100);
          const color = scoreToColor(score ?? 0);
          return `<div><span class="bar" style="width:${pct}px;background:${color}"></span>${label}: ${(score ?? 0).toFixed(3)}</div>`;
        };
        const elevInfo = p.elevationGain != null
          ? `<div>Elev: +${p.elevationGain}m / -${p.elevationLoss}m | Grade: ${p.averageGrade}% avg, ${p.maxGrade}% max | Hilliness: ${p.hillinessIndex}</div>`
          : '';
        const elevChart = p.elevationProfile && p.elevationProfile.length > 1
          ? `<canvas id="elev-chart" width="310" height="70" style="margin-top:4px;width:310px;height:70px;"></canvas>`
          : '';
        const html = `
          <div class="score-popup">
            <div class="name">${p.name || p.id}</div>
            <div>Type: ${p.corridorType} | ${p.lengthKm} km</div>
            <div>Road: ${p.roadClass} | Surface: ${p.surface} (${p.surfaceConfidence})</div>
            <div>Infra: ${p.infraContinuity} | Sep: ${p.separationContinuity} | Stops: ${p.stopDensityPerKm}/km | Crossings: ${p.crossingDensityPerKm}/km</div>
            ${elevInfo}
            ${elevChart}
            <hr style="margin:4px 0;border-color:#555">
            ${barHtml(p.scoreOverall, 'Overall')}
            ${barHtml(p.scoreFlow, 'Flow')}
            ${barHtml(p.scoreSafety, 'Safety')}
            ${barHtml(p.scoreSurface, 'Surface')}
            ${barHtml(p.scoreCharacter, 'Character')}
            ${barHtml(p.scoreScenic, 'Scenic')}
            ${barHtml(p.scoreElevation, 'Elevation')}
          </div>
        `;
        const popup = layer.bindPopup(html, { maxWidth: 350 }).openPopup();

        // Draw elevation chart after popup is open and canvas is in the DOM
        if (p.elevationProfile && p.elevationProfile.length > 1) {
          setTimeout(() => drawElevationChart('elev-chart', p.elevationProfile, p.lengthKm), 10);
        }
      });

      layer.on('popupclose', clearHighlight);
    },
  });

  // Only add to map if the network toggle is checked
  if (document.getElementById('show-network').checked) {
    corridorLayer.addTo(map);
  }
}

function renderConnectors(geojson) {
  if (connectorLayer) {
    map.removeLayer(connectorLayer);
    connectorLayer = null;
  }
  if (!geojson || !geojson.features || geojson.features.length === 0) return;

  connectorLayer = L.geoJSON(geojson, {
    style: () => ({
      color: '#000000',
      weight: 2,
      opacity: 0.6,
      dashArray: '4 3',
    }),
    onEachFeature: (feature, layer) => {
      layer.on('click', () => {
        clearHighlight();
        const coords = feature.geometry.coordinates;
        const latlngs = coords.map(c => [c[1], c[0]]);
        const highlight = L.polyline(latlngs, {
          color: '#ffaa00', weight: 5, opacity: 1, interactive: false,
        });
        highlightGroup = L.layerGroup([highlight]).addTo(map);

        const p = feature.properties;
        const html = `
          <div class="score-popup">
            <div class="name">${p.id}</div>
            <div>Length: ${Math.round(p.lengthMeters)}m</div>
            <div>Crosses major road: ${p.crossesMajorRoad ? 'Yes' : 'No'}</div>
            <div>Signal: ${p.hasSignal ? 'Yes' : 'No'} | Stop: ${p.hasStop ? 'Yes' : 'No'}</div>
            <div>Crossing difficulty: ${p.crossingDifficulty}</div>
            <div>Connects: ${(p.corridorIds || []).join(', ')}</div>
          </div>
        `;
        layer.bindPopup(html, { maxWidth: 300 }).openPopup();
      });
      layer.on('popupclose', clearHighlight);
    },
  });

  // Only add to map if the connector toggle is checked
  if (document.getElementById('show-connectors').checked) {
    connectorLayer.addTo(map);
  }
}

function scoreToColor(score) {
  const s = Math.max(0, Math.min(1, score));
  let r, g;
  if (s < 0.5) {
    const t = s / 0.5;
    r = 204;
    g = Math.round(34 + t * 170);
  } else {
    const t = (s - 0.5) / 0.5;
    r = Math.round(204 - t * 170);
    g = 204;
  }
  return '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + '22';
}

function drawElevationChart(canvasId, profile, lengthKm) {
  const canvas = document.getElementById(canvasId);
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const w = canvas.width;
  const h = canvas.height;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  ctx.scale(dpr, dpr);

  const pad = { top: 12, right: 8, bottom: 16, left: 32 };
  const plotW = w - pad.left - pad.right;
  const plotH = h - pad.top - pad.bottom;

  const minElev = Math.min(...profile);
  const maxElev = Math.max(...profile);
  const elevRange = maxElev - minElev || 1;
  // Add 10% padding to y range
  const yMin = minElev - elevRange * 0.1;
  const yMax = maxElev + elevRange * 0.1;
  const yRange = yMax - yMin;

  const xStep = plotW / (profile.length - 1);

  // Filled area
  ctx.beginPath();
  ctx.moveTo(pad.left, pad.top + plotH);
  for (let i = 0; i < profile.length; i++) {
    const x = pad.left + i * xStep;
    const y = pad.top + plotH - ((profile[i] - yMin) / yRange) * plotH;
    ctx.lineTo(x, y);
  }
  ctx.lineTo(pad.left + plotW, pad.top + plotH);
  ctx.closePath();
  ctx.fillStyle = 'rgba(0, 255, 255, 0.15)';
  ctx.fill();

  // Line
  ctx.beginPath();
  for (let i = 0; i < profile.length; i++) {
    const x = pad.left + i * xStep;
    const y = pad.top + plotH - ((profile[i] - yMin) / yRange) * plotH;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.strokeStyle = '#00ffff';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Y-axis labels
  ctx.fillStyle = '#999';
  ctx.font = '9px monospace';
  ctx.textAlign = 'right';
  ctx.fillText(Math.round(maxElev) + 'm', pad.left - 3, pad.top + 8);
  ctx.fillText(Math.round(minElev) + 'm', pad.left - 3, pad.top + plotH);

  // X-axis label
  ctx.textAlign = 'center';
  ctx.fillText((lengthKm ?? 0) + ' km', pad.left + plotW / 2, h - 2);
}

// ---------------------------------------------------------------------------
// Collapsible sections
// ---------------------------------------------------------------------------
document.querySelectorAll('.section-header').forEach(header => {
  header.addEventListener('click', () => {
    header.classList.toggle('open');
    const body = header.nextElementSibling;
    body.classList.toggle('open');
  });
});

// ---------------------------------------------------------------------------
// Init
// ---------------------------------------------------------------------------
async function init() {
  // Initialize map (will re-center once we get network stats)
  map = L.map('map').setView([42.96, -85.67], 12);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors',
    maxZoom: 19,
  }).addTo(map);

  // Load network stats for centering
  try {
    const statsRes = await fetch('/api/network-stats');
    const stats = await statsRes.json();
    if (stats.center) {
      map.setView([stats.center.lat, stats.center.lng], 12);
    }
  } catch (e) {
    console.warn('Could not load network stats:', e);
  }

  // Show DEM tile coverage on map
  try {
    const demRes = await fetch('/api/dem-coverage');
    const dem = await demRes.json();
    for (const tile of dem.tiles) {
      const b = tile.bounds;
      L.rectangle(
        [[b.minLat, b.minLng], [b.maxLat, b.maxLng]],
        { color: '#00ffff', weight: 2, fillColor: '#00ffff', fillOpacity: 0.05, interactive: false, dashArray: '6 4' }
      ).addTo(map).bindTooltip(tile.filename, { permanent: false, direction: 'center' });
    }
  } catch (e) {
    console.warn('Could not load DEM coverage:', e);
  }

  // Load profiles list
  await loadProfiles();

  // Load defaults
  await loadDefaults();

  // Wire activity change
  document.getElementById('activity').addEventListener('change', () => {
    currentProfile = null;
    updateProfileDropdown();
    loadDefaults();
  });

  // Wire profile change
  document.getElementById('profile').addEventListener('change', () => {
    const val = document.getElementById('profile').value;
    currentProfile = val || null;
    loadDefaults();
  });

  // Wire reset button
  document.getElementById('reset-btn').addEventListener('click', () => {
    currentProfile = null;
    updateProfileDropdown();
    loadDefaults();
  });

  // Wire save button
  document.getElementById('save-btn').addEventListener('click', saveConfig);

  // Wire save-as button
  document.getElementById('save-as-btn').addEventListener('click', saveAsProfile);

  // Wire corridor network visibility toggle
  document.getElementById('show-network').addEventListener('change', (e) => {
    if (!corridorLayer) return;
    if (e.target.checked) {
      map.addLayer(corridorLayer);
    } else {
      map.removeLayer(corridorLayer);
    }
  });

  // Wire connector visibility toggle
  document.getElementById('show-connectors').addEventListener('change', (e) => {
    if (!connectorLayer) return;
    if (e.target.checked) {
      map.addLayer(connectorLayer);
    } else {
      map.removeLayer(connectorLayer);
    }
  });

  // Build distance range buttons
  buildDistanceButtons();

  // Auto-load corridors when the map view changes (disabled — route generation handles this)
  // map.on('moveend', onMoveEnd);
}

async function loadProfiles() {
  try {
    const res = await fetch('/api/profiles');
    profileList = await res.json();
    updateProfileDropdown();
  } catch (e) {
    console.warn('Could not load profiles:', e);
  }
}

function updateProfileDropdown() {
  const activity = document.getElementById('activity').value;
  const select = document.getElementById('profile');
  select.innerHTML = '<option value="">(base)</option>';

  for (const p of profileList) {
    if (p.extends === activity) {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      opt.title = p.description;
      if (p.name === currentProfile) opt.selected = true;
      select.appendChild(opt);
    }
  }
}

async function loadDefaults() {
  const activity = document.getElementById('activity').value;
  document.getElementById('status').textContent = 'Loading defaults...';

  try {
    let url;
    if (currentProfile) {
      url = `/api/defaults?profile=${encodeURIComponent(currentProfile)}`;
    } else {
      url = `/api/defaults?activity=${activity}`;
    }
    const res = await fetch(url);
    const data = await res.json();

    // If profile response, update activity dropdown to match the base
    if (data._profile) {
      document.getElementById('activity').value = data._profile.extends;
      updateProfileDropdown();
    }

    params = data;
    buildControls();
    await doScore();
  } catch (err) {
    document.getElementById('status').textContent = `Error: ${err.message}`;
  }
}

async function saveConfig() {
  const activity = document.getElementById('activity').value;
  const currentParams = readParams();
  const btn = document.getElementById('save-btn');

  btn.textContent = 'Saving...';
  btn.disabled = true;

  try {
    const payload = {
      activityType: activity,
      params: currentParams,
      profileName: currentProfile || undefined,
      asBase: !currentProfile,
    };

    const res = await fetch('/api/save', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });
    const result = await res.json();

    if (result.error) {
      document.getElementById('footer').textContent = `Save error: ${result.error}`;
      btn.textContent = 'Save Failed';
    } else {
      const target = currentProfile ? `profile "${currentProfile}"` : `${activity} base config`;
      document.getElementById('footer').textContent = `Saved ${target}`;
      btn.textContent = 'Saved!';
    }
  } catch (err) {
    document.getElementById('footer').textContent = `Save error: ${err.message}`;
    btn.textContent = 'Save Failed';
  }

  setTimeout(() => {
    btn.textContent = 'Save';
    btn.disabled = false;
  }, 2000);
}

async function saveAsProfile() {
  const name = prompt('Profile name (e.g. "weekend-warrior"):');
  if (!name) return;
  const description = prompt('Short description (optional):') || '';

  const activity = document.getElementById('activity').value;
  const currentParams = readParams();
  const btn = document.getElementById('save-as-btn');

  btn.textContent = 'Saving...';
  btn.disabled = true;

  try {
    const res = await fetch('/api/save-as', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, description, activityType: activity, params: currentParams }),
    });
    const result = await res.json();

    if (result.error) {
      document.getElementById('footer').textContent = `Save error: ${result.error}`;
      btn.textContent = 'Save Failed';
    } else {
      document.getElementById('footer').textContent = `Saved new profile "${name}"`;
      btn.textContent = 'Saved!';
      // Reload profiles and select the new one
      await loadProfiles();
      currentProfile = name;
      updateProfileDropdown();
    }
  } catch (err) {
    document.getElementById('footer').textContent = `Save error: ${err.message}`;
    btn.textContent = 'Save Failed';
  }

  setTimeout(() => {
    btn.textContent = 'Save as New Profile';
    btn.disabled = false;
  }, 2000);
}

// ---------------------------------------------------------------------------
// Auto-load corridors on map pan/zoom
// ---------------------------------------------------------------------------

function onMoveEnd() {
  clearTimeout(moveDebounceTimer);
  moveDebounceTimer = setTimeout(loadCurrentView, 800);
}

async function loadCurrentView() {
  if (loadInFlight) return;

  const bounds = map.getBounds();
  const viewBbox = {
    minLat: bounds.getSouthWest().lat,
    maxLat: bounds.getNorthEast().lat,
    minLng: bounds.getSouthWest().lng,
    maxLng: bounds.getNorthEast().lng,
  };

  loadInFlight = true;
  document.getElementById('status').textContent = 'Fetching corridors...';

  try {
    const res = await fetch('/api/load-location', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ bbox: viewBbox }),
    });
    const result = await res.json();

    if (result.error) {
      document.getElementById('footer').textContent = `Load error: ${result.error}`;
      document.getElementById('status').textContent = 'Error';
    } else if (result.cached) {
      // Area already covered — just re-score existing corridors
      document.getElementById('status').textContent = 'Ready';
      await doScore();
    } else {
      document.getElementById('footer').textContent =
        `Loaded ${result.corridorCount} corridors, ${result.connectorCount} connectors (${result.timeMs}ms)`;
      document.getElementById('status').textContent = 'Ready';
      await doScore();
    }
  } catch (err) {
    document.getElementById('footer').textContent = `Load error: ${err.message}`;
    document.getElementById('status').textContent = 'Error';
  }

  loadInFlight = false;
}

// ---------------------------------------------------------------------------
// Route generation
// ---------------------------------------------------------------------------

function clearRoute() {
  if (routeLayer) { map.removeLayer(routeLayer); routeLayer = null; }
  if (startMarker) { map.removeLayer(startMarker); startMarker = null; }
}

// Distance buckets: [minMiles, maxMiles]
const DISTANCE_BUCKETS = [
  [0, 10], [10, 20], [20, 30], [30, 40], [40, 50],
  [50, 60], [60, 70], [70, 80], [80, 90], [90, 100],
  [100, 125], [125, 150], [150, 175], [175, 200],
];

let activeDistBtn = null;

function buildDistanceButtons() {
  const container = document.getElementById('distance-buttons');
  container.innerHTML = '';
  for (const [lo, hi] of DISTANCE_BUCKETS) {
    const btn = document.createElement('button');
    btn.className = 'dist-btn';
    btn.textContent = `${lo}-${hi}`;
    btn.title = `Generate ${lo}-${hi} mi loop (target: ${(lo + hi) / 2} mi)`;
    btn.addEventListener('click', () => generateRoute(btn, (lo + hi) / 2));
    container.appendChild(btn);
  }
}

async function generateRoute(btn, targetMiles) {
  const activity = document.getElementById('activity').value;
  const currentParams = readParams();
  const targetMeters = Math.round(targetMiles * 1609.34);

  // Disable all distance buttons during generation
  const allBtns = document.querySelectorAll('.dist-btn');
  allBtns.forEach(b => b.disabled = true);
  if (activeDistBtn) activeDistBtn.classList.remove('active');
  btn.classList.add('active');
  activeDistBtn = btn;
  const origText = btn.textContent;
  btn.textContent = '...';
  document.getElementById('status').textContent = `Generating ${targetMiles} mi route...`;

  try {
    const res = await fetch('/api/generate-route', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        activityType: activity,
        scoringParams: currentParams,
        loopSearchParams: {
          startCoordinate: { lat: 42.98656566989668, lng: -85.65484294159361 },
          targetDistanceMeters: targetMeters,
        },
      }),
    });
    const data = await res.json();

    if (data.error) {
      document.getElementById('footer').textContent = `Route error: ${data.error}`;
      document.getElementById('status').textContent = 'Error';
      return;
    }

    clearRoute();

    // Add start marker
    startMarker = L.circleMarker([42.98656566989668, -85.65484294159361], {
      radius: 8, color: '#fff', fillColor: '#2563eb', fillOpacity: 1, weight: 3,
    }).addTo(map).bindTooltip('Start', { permanent: true, direction: 'right', offset: [10, 0] });

    // Render route GeoJSON
    routeLayer = L.geoJSON(data, {
      style: (feature) => ({
        color: feature.properties.stroke || '#2563eb',
        weight: feature.properties['stroke-width'] || 4,
        opacity: feature.properties['stroke-opacity'] || 0.9,
      }),
      onEachFeature: (feature, layer) => {
        const p = feature.properties;
        const label = p.isPrimary ? 'Primary Route' : `Alternative ${p.routeIndex}`;
        layer.bindPopup(`
          <div class="score-popup">
            <div class="name">${label}</div>
            <div>Distance: ${p.distanceKm} km (${(p.distanceKm * 0.621371).toFixed(1)} mi)</div>
            <div>Score: ${p.score} | Stops: ${p.totalStops} | Flow: ${p.flowScore}</div>
            <div>Segments: ${p.segmentCount}</div>
            ${p.elevationGain != null ? `<div>Elevation: +${p.elevationGain}m / -${p.elevationLoss}m</div>` : ''}
          </div>
        `, { maxWidth: 300 });
      },
    }).addTo(map);

    // Zoom to fit the route
    const bounds = routeLayer.getBounds();
    if (bounds.isValid()) map.fitBounds(bounds, { padding: [40, 40] });

    // Render the corridor network used for routing (underneath the route)
    if (data.corridorNetwork) {
      lastGeoJson = data.corridorNetwork;
      renderGeoJson(data.corridorNetwork);
    }

    const meta = data._meta || {};
    const actualMi = meta.primary?.totalDistanceMeters ? (meta.primary.totalDistanceMeters / 1609.34).toFixed(1) : '?';
    document.getElementById('footer').textContent =
      `Route: ${actualMi} mi (target: ${targetMiles} mi) | ${meta.routeCount} alternative(s) | ${meta.searchTimeMs}ms | ${data.corridorNetwork?._meta?.corridorCount ?? '?'} corridors`;
    document.getElementById('status').textContent = 'Ready';
  } catch (err) {
    document.getElementById('footer').textContent = `Route error: ${err.message}`;
    document.getElementById('status').textContent = 'Error';
  }

  btn.textContent = origText;
  allBtns.forEach(b => b.disabled = false);
}

init();
</script>
</body>
</html>
